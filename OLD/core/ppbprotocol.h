#ifndef PPBPROTOCOL_H
#define PPBPROTOCOL_H

#pragma once

#include <cstdint>


// ===== ОСНОВНЫЕ КОНСТАНТЫ =====
constexpr uint16_t BROADCAST_ADDRESS = 0xFFFF;

// ===== КОМАНДЫ ТУ ===
enum class TechCommand : uint8_t {

    TS = 0x00,          // выдать тех.состояние
    TC = 0x01,          // принять тех.управление
    VERS = 0x02,        // выдать версию
    VOLUME = 0x03,      // принять том исполняемого ПО
    CHECKSUM = 0x04,    // выдать контрольную сумму
    PROGRAMM = 0x05,    // обновить исп файл ПО
    CLEAN = 0x0A,       // очистить временный файл ПО
    PRBS_M2S = 0x0B,    // принять тестовую последовательность данных
    BER_T = 0x0C,       // выдать коэф ошибок ТУ
    BER_F = 0x0D,       // выдать коэф ошибок ФУ
    PRBS_S2M = 0x0E,    // выдать тестовую последовательность
    DROP = 0x0F         // выдать кол-во отброшенных пакетов ФУ по контр сумме

};

// ===== ФУ КОМАНДЫ =====
enum class FuCommand : uint8_t
{
    TRANSMIT  = 0,
    RECEIVE  = 1
};

// ===== ПРИЗНАК ПАКЕТА =====
enum class Sign : uint8_t
{
    TU = 0,
    FU = 1
};


// ===== БАЗОВЫЙ ЗАПРОС (8 байт) =====
#pragma pack(push, 1)
struct BaseRequest {
    uint16_t address;     // 2 байта - адрес ППБ (0-15)
    uint8_t command;      // 1 байт - команда (TechCommand)
    uint8_t sign;         // 1 байт - признак TU/FU (Sign)
    uint8_t fu_period;    // 1 байт - период ФУ (0 для команды 0)
    uint8_t fu_data[3];   // 3 байта - данные ФУ
};
#pragma pack(pop)

// ===== ОТВЕТ ОТ ППБ ДЛЯ ТУ КОМАНД (с CRC) =====
#pragma pack(push, 1)
struct PPBResponse {
    uint16_t address;     // 2 байта - адрес ППБ
    uint8_t status;       // 1 байт - статус (0x00 - ОК, 0x01 - ошибка)
    uint8_t crc;          // 1 байт - CRC8
};
#pragma pack(pop)

// ===== ОТВЕТ ОТ БРИДЖА ДЛЯ ФУ КОМАНД (без CRC) =====
#pragma pack(push, 1)
struct BridgeResponse {
    uint16_t address;     // 2 байта - адрес ППБ
    uint8_t command;      // 1 байт - команда
    uint8_t status;       // 1 байт - статус (0 - ошибка, 1 - ОК)
};
#pragma pack(pop)

// ===== ОК-ПАКЕТ ОТВЕТ СТАРЫЙ (4 байта) =====
#pragma pack(push, 1)
struct OkResponse {
    uint16_t address;     // 2 байта - адрес ППБ
    uint8_t command;      // 1 байт - команда
    uint8_t status;       // 1 байт - статус (0 - ошибка, 1 - ОК)
};
#pragma pack(pop)

// ===== ПАКЕТ ДАННЫХ ДЛЯ ТЕСТОВЫХ ПОСЛЕДОВАТЕЛЬНОСТЕЙ (4 байта) =====
#pragma pack(push, 1)
struct DataPacket {
    uint8_t data[3];      // 3 байта данных
    uint8_t crc;          // 1 байт CRC8 (используем общий алгоритм)
};
#pragma pack(pop)

struct PacketFourBytesResponse
{

};


// ===== СТАТУС ППБ (для внутреннего использования) =====

struct PPBStatus {
    uint8_t address;
    bool powerOk;
    bool isTransmitMode;
    bool isReceiveMode;

    // Каналы
    struct Channel {
        float power;        // Мощность, Вт
        float temperature;  // Температура, °C
        float vswr;         // КСВН
        bool isOk;          // Статус канала
    } channel1, channel2;

    // Технические параметры
    uint32_t pulseDuration;  // Длительность импульса, мкс
    uint8_t dutyCycle;       // Скважность
    uint32_t pulseDelay;     // Задержка импульса, мкс

    // Флаги ошибок
    bool hasErrors;
    bool droppedPackets;
};

#endif // PPBPROTOCOL_H

/*
 * опросник отправляет пакет PacketRequest.
 * Если признак ТУ:
 * все что после него прочитано НЕ будет, можно ставить 0, мусор и тд.
 * в ответ на такой запрос мы получаем "ОК" пакет(4 байта)
 * затем в зависимости от команды ТУ мы либо ждём ответа, либо шлем пакеты (далее общение строго 4 байта)
 * примеры:
 * "сценарий" с тестовыми последовательностями:
 * ЗАПРОС адрес(2 байта) 01, команда 0x0B, 0, {0}. Ответ адрес(2байта) 01, 1/0(окнеок), CRC8. CRC можно не проверять, но его будут слать.
 * Далее опросник формирует 256 пакетов по 4 байта [][][][CRC8]. Сохраняем откправленные пакеты в оперативную память. ЗДЕСЬ СЧИТАЕМ СРС. функция и таблица общая
 * ЗАПРС  адрес(2 байта) 01, команда 0x0E, 0, {0}. Ответ адрес(2байта) 01, 1/0(окнеок), CRC8.
 * Далее опросник в этом случае заводит таймер, счётчик = N(N зависит от КОМАНД. К примеру для тест последовательности N=256)
 * начинаем получать пакеты от ппб: 4 байта: [][][][crc8] - копия того что мы отправили.
 * полученные пакеты сохраняются в оперативку. Сравниваются с отправленными. Логируются так |отправленные|полученные|. Если все в логи пишется данные сошлись. Если не сходится пишется не сошлось\строки
 * удаляем данные.
 *
 * Если признак ФУ:
 * если fu команда = 0. то период 0. далее ппб не читает
 * если fu команда = 1, то период > 0(10-254), опросник заполняет данные, ппб их читает
 * после периода идёт период в нуле(10-254)
 * в ответ на ФУ признак приходит след:
 * Ок-пакет: адрес,команда,1/0
 *
 *
 * пока что всё
 *
 * Частота общения опросника с ппб 10ГЦ.
 *
 * план мининимум:
 * кнопка подключиться отправляет команду TS = 0x00. Считаем подключившимися если нам пришел ответ.
 * на  любую команду первым приходит ОК-пакет.
 * кнопка СБРОС - сбрасывает ошибки.
 * кнопка опрос ППБ - TS команда.
 * Управление ППБ: автоопрос - отправка  команд TS, PRBS_M2S, PRBS_S2M на частоте общения (чаще TS). Кнопка выдать тест последовательнось - запуск "сценария" с тестом(описал выше)
 * параметры генератора АКИП - по сути это ФУ.
 * сценарии и прочее заглушку(блокируем пока кнопки)
 *
 * План далее:
 * реализовать ПУЛЬТ(отдельное окно, запускается по кнопке из главного окна). Там кнопки комманд.
 * релизовать команду за командой
 * подключаем сценарии.
 *
 *
 *
 * при ту командах мы общаемся с ппб через переходник RS-Ethernet. Он не отбрасывет CRC из пакеты. Нам же не нужно проверять, тк мы получаем UDP пакет со своим СРС.
 * НО нам нужно отправлять пакеты, которые содержат ДАННЫЕ, с СРС.
 *
 * при ФУ командах есть бридж. поэтому срс здесь не высчитываем, бридж сам сделает это.
 */
